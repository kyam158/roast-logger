<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Roast Logger</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>

<style>
body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,sans-serif;
  background:#fafafa;
  user-select:none;
}
#wrap{padding:10px}
#chartWrap{height:45vh}
#time{
  font-size:28px;
  font-weight:bold;
  text-align:center;
  margin:8px 0;
}
button,input{
  width:100%;
  padding:12px;
  margin:6px 0;
  font-size:16px;
}
.row{display:flex;gap:6px}
.row>*{flex:1}
label{font-size:13px;color:#555}
#dropBtn{background:#d32f2f;color:#fff;font-weight:bold}
</style>
</head>

<body>
<div id="wrap">

<div id="chartWrap"><canvas id="chart"></canvas></div>
<div id="time">0:00</div>

<button id="startBtn">焙煎開始</button>

<label>豆温 (℃)</label>
<div class="row">
  <input id="tempInput" type="number" value="150">
  <button id="tempSet">決定</button>
</div>

<label>ガス圧 (<span id="gasLabel">2.5</span>)</label>
<input id="gasInput" type="range" min="0" max="5" step="0.5" value="2.5">

<button id="dryBtn">Dry End（長押し）</button>
<button id="fcBtn">1ハゼ（長押し）</button>
<button id="dropBtn">DROP</button>

</div>

<script>
let startTime=null,timer=null;
let temp=150,gas=2.5;
let temps=[],gases=[],rors=[];
let dryEnd=null,fc=null,drop=null;

const sec=()=>startTime?Math.floor((Date.now()-startTime)/1000):0;
const fmt=s=>`${Math.floor(s/60)}:${String(s%60).padStart(2,"0")}`;

function calcRoR(){
  rors=[];
  for(let i=30;i<temps.length;i++){
    if(temps[i]!=null&&temps[i-30]!=null){
      rors.push({x:i,y:(temps[i]-temps[i-30])*2});
    }
  }
}

/* ===== フェーズ情報 ===== */
function phases(){
  return [
    {s:0,e:dryEnd,c:"#fbc02d"},
    {s:dryEnd,e:fc,c:"#fb8c00"},
    {s:fc,e:drop,c:"#e53935"}
  ];
}

/* ===== Chart Plugin ===== */
const phasePlugin={
  id:"phase",
  beforeDraw(chart){
    const {ctx,chartArea,scales}=chart;
    ctx.save();
    phases().forEach(p=>{
      if(p.s==null||p.e==null) return;
      const x0=scales.x.getPixelForValue(p.s);
      const x1=scales.x.getPixelForValue(p.e);
      ctx.fillStyle=p.c+"33";
      ctx.fillRect(x0,chartArea.top,x1-x0,chartArea.bottom-chartArea.top);
    });
    ctx.restore();
  },
  afterDraw(chart){
    const {ctx,scales,chartArea}=chart;
    ctx.save();
    if(dryEnd!=null){
      const x=scales.x.getPixelForValue(dryEnd);
      ctx.strokeStyle="#fbc02d";
      ctx.beginPath();ctx.moveTo(x,chartArea.top);ctx.lineTo(x,chartArea.bottom);ctx.stroke();
    }
    if(fc!=null){
      const x=scales.x.getPixelForValue(fc);
      ctx.strokeStyle="#e64a19";
      ctx.beginPath();ctx.moveTo(x,chartArea.top);ctx.lineTo(x,chartArea.bottom);ctx.stroke();
    }
    ctx.restore();
  }
};

/* ===== Chart ===== */
const chart=new Chart(chartWrap.firstChild,{
  type:"line",
  data:{datasets:[]},
  options:{
    animation:false,
    scales:{
      x:{type:"linear",min:0,max:600,ticks:{stepSize:60,callback:v=>fmt(v)}},
      y:{min:0,max:260},
      yR:{position:"right",min:-10,max:10,grid:{drawOnChartArea:false}}
    }
  },
  plugins:[phasePlugin]
});

/* ===== 描画 ===== */
function draw(){
  const t=sec();
  time.textContent=fmt(t);
  chart.options.scales.x.max=t>600?900:600;

  chart.data.datasets=[
    {label:"Temp",data:temps.map((v,i)=>v!=null?{x:i,y:v}:null),borderWidth:2},
    {label:"RoR",data:rors,borderColor:"#7b1fa2",yAxisID:"yR"},
    {label:"Gas",data:gases.map((v,i)=>v!=null?{x:i,y:v}:null),borderDash:[4,4],yAxisID:"yR"}
  ];
  chart.update();
}

/* ===== 焙煎開始 ===== */
startBtn.onclick=()=>{
  startTime=Date.now();
  dryEnd=fc=drop=null;
  temps=[];gases=[];rors=[];
  clearInterval(timer);
  timer=setInterval(()=>{
    const t=sec();
    temps[t]=temp;
    gases[t]=gas;
    calcRoR();
    draw();
  },1000);
};

/* ===== 入力 ===== */
tempSet.onclick=()=>temp=parseInt(tempInput.value);
gasInput.oninput=()=>{
  gas=parseFloat(gasInput.value);
  gasLabel.textContent=gas.toFixed(1);
};

/* ===== 長押し ===== */
let hold=null;
const startHold=f=>hold=setTimeout(f,600);
const cancelHold=()=>clearTimeout(hold);
dryBtn.onpointerdown=e=>{e.preventDefault();startHold(()=>dryEnd=sec());};
fcBtn.onpointerdown=e=>{e.preventDefault();startHold(()=>fc=sec());};
[dryBtn,fcBtn].forEach(b=>{b.onpointerup=cancelHold;b.onpointercancel=cancelHold;});

/* ===== DROP ===== */
dropBtn.onclick=()=>{ if(startTime&&!drop) drop=sec(); };
</script>
</body>
</html>
